""" Example: plotting coloured limit sets of groups uniformising (1;2)-compression bodies.

    Let G be a group generated by two parabolics sharing a common fixed point and an independent loxodromic. Such a group
    generally uniformises a 3-manifold with one genus 2 boundary component and one genus 1 boundary component (a rank 2 cusp).

    See [LP], though we use different generators.

    [LP] M. Lackenby and J. Purcell, "Geodesics and compression bodies" (2014). https://arxiv.org/abs/1302.3652
"""
from bella import cayley
from mpmath import mp
# import numpy as np
import holoviews as hv
from holoviews import opts
import pandas as pd
from bella.hvhelp import makeCircles,pairsToCircles
from holoviews.operation.datashader import datashade
from holoviews.operation.resample import ResampleOperation2D
hv.extension('bokeh')
from functools import reduce
hv.output(fig='png', dpi=600)
fs = {'labels': 8, 'ticks': 6}

# mp.dps = 20
# print(cayley.mp.dps)


ResampleOperation2D.width=2400
ResampleOperation2D.height=2400

class LackenbyPurcellGroup(cayley.GroupCache):
    def __init__(self, α, β, λ, with_extras=False):
        self.α = α
        self.β = β
        self.λ = λ

        P = mp.matrix([[1, α], [0, 1]])
        Q = mp.matrix([[1, β], [0, 1]])
        M = mp.matrix([[λ, λ**2 - 1], [1, λ]])

        gens = [P, Q, M]
        if with_extras:
            gens += [P**-1*M*Q**-1, M*P**-1*M*Q**-1, P@Q**-1@M@P**-1@Q@M**-1]

        super().__init__(gens, names=list('XYMABC'))



logpoints = 7

θ = 2*mp.pi/3
α = 2+2*mp.cos(θ)+2j*mp.sin(θ)
β = 2+2*mp.cos(θ)-2j*mp.sin(θ)
λ=1

# α =(2*mp.sqrt(2)) * mp.exp(-1j*mp.pi/4)
# β = 2+2*mp.exp(1j*mp.pi/4)
# λ = 1

G = LackenbyPurcellGroup(α, β, λ)
H = G.subgroup([(2,3,2,4), (2,)])

# α = α+β
# β = 2+1j+mp.sqrt(3)
G = LackenbyPurcellGroup(α, β, λ, with_extras = True)

limit_set_G = G.coloured_limit_set_fast(10**logpoints)
print('limit set G finished')
#
stuff = [limit_set_G]
for lat in [α, β, α+β, α-β, -α+β, -α,-β,-α-β]:
      df = limit_set_G.copy()
      df['z'] = df['x']+1j*df['y']
      df['z'] = df['z'].apply(lambda z: complex(z+lat))
      df['x'] = df['z'].apply(lambda z: z.real)
      df['y'] = df['z'].apply(lambda z: z.imag)
      del df['z']
      stuff.append(df)
limit_set_G = pd.concat(stuff, axis=0)

limit_set_H = H.coloured_limit_set_fast(10**5)
print('limit set H finished')

circles = G.subgroup([(2,)]).coloured_isometric_circles_bfs(1)
circles_list = [circles]
for z in [α, -α, β, -β, α+β, α-β, -α+β, -α-β]:
    circles2 = circles.copy()
    circles2['x'] += float(z.real)
    circles2['y'] += float(z.imag)
    circles_list.append(circles2)
circles = pd.concat(circles_list)
square = [(float(z.real), float(z.imag)) for z in [(α + β)/2, (α - β)/2, (-α - β)/2, (-α + β)/2, (α + β)/2]]
print('CIRCLES DONE')

scatter = datashade(hv.Scatter(limit_set_G, kdims = ['x'], vdims = ['y','colour']).opts(data_aspect=1, marker = "dot", size = .01)\
            .redim(x=hv.Dimension('x', range=(-3.5,3.5)),y=hv.Dimension('y', range=(-3.5, 3.5))), width=1200, cmap=['gray'], min_alpha=1)\
        * hv.Path(square).opts(color = "black")\
        * makeCircles(circles, kdims = ['x'], vdims = ['y','radius']).opts(radius='radius', color = 'black')\
        * hv.Scatter(limit_set_H, kdims = ['x'], vdims = ['y','colour']).opts(marker = "dot", size = 10,  color = 'k')
hv.save(scatter.opts(width=1200,data_aspect=1), "circles_2pi3.png")
