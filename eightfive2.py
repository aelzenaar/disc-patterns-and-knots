""" Example: plotting coloured limit sets of groups uniformising (1;2)-compression bodies.

    Let G be a group generated by two parabolics sharing a common fixed point and an independent loxodromic. Such a group
    generally uniformises a 3-manifold with one genus 2 boundary component and one genus 1 boundary component (a rank 2 cusp).

    See [LP], though we use different generators.

    [LP] M. Lackenby and J. Purcell, "Geodesics and compression bodies" (2014). https://arxiv.org/abs/1302.3652
"""
from bella import cayley
from mpmath import mp
# import numpy as np
import holoviews as hv
from holoviews import opts
import pandas as pd
from bella.hvhelp import makeCircles,pairsToCircles
from holoviews.operation.datashader import datashade, spread
from holoviews.operation.resample import ResampleOperation2D
hv.extension('bokeh')
from functools import reduce
hv.output(fig='png', dpi=600)
fs = {'labels': 8, 'ticks': 6}

# mp.dps = 20
# print(cayley.mp.dps)


ResampleOperation2D.width=1600
ResampleOperation2D.height=1600

class LackenbyPurcellGroup(cayley.GroupCache):
    def __init__(self, α, β, λ, with_extras=False):
        self.α = α
        self.β = β
        self.λ = λ

        P = mp.matrix([[1, α], [0, 1]])
        Q = mp.matrix([[1, β], [0, 1]])
        M = mp.matrix([[λ, λ**2 - 1], [1, λ]])

        gens = [P, Q, M]
        names = list('PQM')
        if with_extras:
            gens += [Q**-1@P**-1@M@M, Q**-1@P**-1@M@M@M@P**-1, M@P**-1]
            names += list('XYZ')

        super().__init__(gens, names=names)



logpoints = 7

# θ = mp.pi/6
# α = 2+2*mp.cos(θ)+2j*mp.sin(θ)
# β = 2+2*mp.cos(θ)-2j*mp.sin(θ)
# λ=1

α = 1.75806 - 2.7734j
β = 6.45368 - 4.8311j
λ = -0.468782 - 0.357845j

G = LackenbyPurcellGroup(α, β, λ)
H1 = G.subgroup([G.fancyword_to_word("pMM"), G.fancyword_to_word("MppQ")])
H2 = G.subgroup([G.fancyword_to_word("MMp"), G.fancyword_to_word("QppM")])
seeds = [G.fixed_points(x)[0] for x in [(2,3,3,1,), (3,2,2,)]]

β = β - 2*α # Qnew = Q - P
G = LackenbyPurcellGroup(α, β, λ, with_extras = True)

# seeds = [G.fixed_points(x)[0] for x in [(2,), (3,2,0), (0,2,3), (4,2,1), (1,2,4),(3,2,2,), (2,3,3,1,)]]

limit_set_G = pd.concat([G.coloured_limit_set_fast(10**logpoints, seed=seed) for seed in seeds])
print('limit set G finished')

# limit_set_G.drop(limit_set_G[limit_set_G.x**2 + limit_set_G.y**2 > 10].index)

stuff = [limit_set_G]
for lat in [α, β, α+β, α-β, -α+β, -α,-β,-α-β]:
      df = limit_set_G.copy()
      df['z'] = df['x']+1j*df['y']
      df['z'] = df['z'].apply(lambda z: complex(z+lat))
      df['x'] = df['z'].apply(lambda z: z.real)
      df['y'] = df['z'].apply(lambda z: z.imag)
      del df['z']
      stuff.append(df)
limit_set_G = pd.concat(stuff, axis=0)
del stuff
# stuff = [limit_set_G]
# for lat in [α, β, α+β, α-β, -α+β, -α,-β,-α-β]:
#       df = limit_set_G.copy()
#       df['z'] = df['x']+1j*df['y']
#       df['z'] = df['z'].apply(lambda z: complex(z+lat))
#       df['x'] = df['z'].apply(lambda z: z.real)
#       df['y'] = df['z'].apply(lambda z: z.imag)
#       del df['z']
#       stuff.append(df)
# limit_set_G = pd.concat(stuff, axis=0)
# del stuff

limit_set_H = pd.concat([H1.coloured_limit_set_fast(10**5), H2.coloured_limit_set_fast(10**5)])
print('limit set H finished')

circles0 = [G.subgroup([(2,)]).isometric_circle(w) for w in G.subgroup([(2,)]).free_cayley_graph_bfs(1)]
circles = circles0.copy()
for z in [α, β, α+β, α-β, -α+β, -α,-β,-α-β]:
    circles += [(cen + z, rad) for cen, rad in circles0]


circle_scatters = [hv.Ellipse(float(centre.real), float(centre.imag), float(radius)*2).opts(color='k') for (centre, radius) in circles if radius != mp.inf]
square = [(float(z.real), float(z.imag)) for z in [(α + β)/2, (α - β)/2, (-α - β)/2, (-α + β)/2, (α + β)/2]]
print('CIRCLES DONE')

scatter = datashade(hv.Scatter(limit_set_G, kdims = ['x'], vdims = ['y','colour']).opts(data_aspect=1, marker = "dot", size = .01)\
            .redim(x=hv.Dimension('x', range=(-3.5,3.5)),y=hv.Dimension('y', range=(-3.5, 3.5))), width=800, cmap=['gray'], min_alpha=1)\
        * hv.Path(square).opts(color = "black")\
        * hv.Scatter(limit_set_H, kdims = ['x'], vdims = ['y','colour']).opts(marker = "dot", size = 4,  color = 'k')
for s in circle_scatters:
    scatter *= s
hv.save(scatter.opts(width=800,data_aspect=1), "eightfive_cusp_limit_new.png")
